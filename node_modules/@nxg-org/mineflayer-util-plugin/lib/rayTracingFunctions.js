"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RayTraceFunctions = void 0;
const vec3_1 = require("vec3");
const iterators_1 = require("./calcs/iterators");
function getViewDirection(pitch, yaw) {
    const csPitch = Math.cos(pitch);
    const snPitch = Math.sin(pitch);
    const csYaw = Math.cos(yaw);
    const snYaw = Math.sin(yaw);
    return new vec3_1.Vec3(-snYaw * csPitch, snPitch, -csYaw * csPitch);
}
class RayTraceFunctions {
    constructor(bot) {
        this.bot = bot;
    }
    blockAtEntityCursor({ position, height, yaw, pitch }, maxDistance = 256, matcher = null) {
        const eyePosition = position.offset(0, height, 0);
        const viewDirection = getViewDirection(pitch, yaw);
        return this.bot.world.raycast(eyePosition, viewDirection, maxDistance, matcher);
    }
    entityAtCursor(maxDistance = 3.5) {
        return this.entityAtEntityCursor(this.bot.entity, maxDistance);
    }
    entityAtEntityCursor(entity, maxDistance = 3.5) {
        var _a;
        const block = this.blockAtEntityCursor(entity, maxDistance);
        maxDistance = (_a = block === null || block === void 0 ? void 0 : block.intersect.distanceTo(this.bot.entity.position)) !== null && _a !== void 0 ? _a : maxDistance;
        const entities = Object.values(this.bot.entities).filter((e) => e.type !== "object" && e.username !== entity.username && e.position.distanceTo(entity.position) <= maxDistance);
        const dir = new vec3_1.Vec3(-Math.sin(entity.yaw) * Math.cos(entity.pitch), Math.sin(entity.pitch), -Math.cos(entity.yaw) * Math.cos(entity.pitch));
        const iterator = new iterators_1.RaycastIterator(entity.position.offset(0, entity.height, 0), dir.normalize(), maxDistance);
        let targetEntity = null;
        let targetDist = maxDistance;
        for (let i = 0; i < entities.length; i++) {
            const e = entities[i];
            const w = e.height >= 1.62 && e.height <= 1.99 || e.height === 2.9 ? 0.3 : e.height / 2;
            const shapes = [[-w, 0, -w, w, e.height + (e.height === 1.62 ? 0.18 : 0), w]];
            const intersect = iterator.intersect(shapes, e.position);
            if (intersect) {
                const entityDir = e.position.minus(entity.position); // Can be combined into 1 line
                const sign = Math.sign(entityDir.dot(dir));
                if (sign !== -1) {
                    const dist = entity.position.distanceTo(intersect.pos);
                    if (dist < targetDist) {
                        targetEntity = e;
                        targetDist = dist;
                    }
                }
            }
        }
        return targetEntity;
    }
}
exports.RayTraceFunctions = RayTraceFunctions;
