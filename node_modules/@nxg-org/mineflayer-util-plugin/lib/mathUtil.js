"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MathFunctions = void 0;
const vec3_1 = require("vec3");
const PI = Math.PI;
const PI_2 = Math.PI * 2;
const TO_RAD = PI / 180;
const TO_DEG = 1 / TO_RAD;
const FROM_NOTCH_BYTE = 360 / 256;
// From wiki.vg: Velocity is believed to be in units of 1/8000 of a block per server tick (50ms)
const FROM_NOTCH_VEL = 1 / 8000;
class MathFunctions {
    constructor() {
        this.toNotchianYaw = (yaw) => this.toDegrees(PI - yaw);
        this.toNotchianPitch = (pitch) => this.toDegrees(-pitch);
        this.fromNotchianYawByte = (yaw) => this.fromNotchianYaw(yaw * FROM_NOTCH_BYTE);
        this.fromNotchianPitchByte = (pitch) => this.fromNotchianPitch(pitch * FROM_NOTCH_BYTE);
    }
    euclideanMod(numerator, denominator) {
        const result = numerator % denominator;
        return result < 0 ? result + denominator : result;
    }
    toRadians(degrees) {
        return TO_RAD * degrees;
    }
    toDegrees(radians) {
        return TO_DEG * radians;
    }
    fromNotchianYaw(yaw) {
        return this.euclideanMod(PI - this.toRadians(yaw), PI_2);
    }
    fromNotchianPitch(pitch) {
        return this.euclideanMod(this.toRadians(-pitch) + PI, PI_2) - PI;
    }
    fromNotchVelocity(vel) {
        return new vec3_1.Vec3(vel.x * FROM_NOTCH_VEL, vel.y * FROM_NOTCH_VEL, vel.z * FROM_NOTCH_VEL);
    }
    pointToYawAndPitch(bot, point) {
        const delta = point.minus(bot.entity.position.offset(0, bot.entity.height, 0));
        return this.dirToYawAndPitch(delta);
    }
    dirToYawAndPitch(dir) {
        const yaw = Math.atan2(-dir.x, -dir.z);
        const groundDistance = Math.sqrt(dir.x * dir.x + dir.z * dir.z);
        const pitch = Math.atan2(dir.y, groundDistance);
        return { yaw: yaw, pitch: pitch };
    }
}
exports.MathFunctions = MathFunctions;
