"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityFunctions = void 0;
const aabb_1 = require("./calcs/aabb");
class EntityFunctions {
    constructor(bot) {
        this.bot = bot;
        this.healthSlot = 7;
        this.bot.on("spawn", () => __awaiter(this, void 0, void 0, function* () {
            // await this.bot.util.sleep(1000)
            // const slot = this.bot.entity.metadata.slice(5).findIndex((data) => Number(data) === 20);
            // if (slot > 0) {
            //     this.healthSlot = slot + 5;
            // }
            this.healthSlot = Number(this.bot.version.split(".")[1]) <= 16 ? 7 : 9;
        }));
    }
    /**
     * TODO: Version specific right now. Generalize. Unknown method.
     *
     * Checks if main hand is activated.
     * @returns boolean
     */
    isMainHandActive(entity) {
        return (entity !== null && entity !== void 0 ? entity : this.bot.entity).metadata[6] === 2; //as any & (1 | 0)) === (1 | 0);
    }
    /**
     * TODO: Version specific right now. Generalize. Unknown method.
     *
     * Checks if offhand is activated.
     * @returns boolean
     */
    isOffHandActive(entity) {
        return (entity !== null && entity !== void 0 ? entity : this.bot.entity).metadata[6] === 3; //& (1 | 2)) === (1 | 2);
    }
    /**
     * TODO: Version specific right now. Generalize. Unknown method.
     * @param metadata metadata from Prismarine-Entity Entity.
     * @returns number
     */
    getHealth(entity) {
        var _a, _b;
        entity !== null && entity !== void 0 ? entity : (entity = this.bot.entity);
        const metadata = entity.metadata;
        const healthSlot = this.healthSlot; //metadata[this.healthSlot] ? this.healthSlot : metadata.findIndex((met) => Number(met) > 1 && Number(met) <= 20);
        let health = Number(metadata[healthSlot]);
        if (!health || health === 0)
            health = entity === this.bot.entity ? (_a = this.bot.entity.health) !== null && _a !== void 0 ? _a : 0 : 0;
        // console.log(health + (Number(metadata[this.healthSlot + 4]) ?? 0))
        return health + ((_b = Number(metadata[this.healthSlot + 4])) !== null && _b !== void 0 ? _b : 0);
    }
    /**
     *
     * @param metadata Must be FULL metadata object.
     * @returns number
     */
    getHealthFromMetadata(metadata) {
        var _a;
        return (_a = Number(metadata[this.healthSlot]) + Number(metadata[this.healthSlot + 4])) !== null && _a !== void 0 ? _a : undefined;
    }
    /**
     * TODO: Version specific right now. Generalize. Unknown method.
     * @param metadata metadata from Prismarine-Entity Entity.
     * @returns
     */
    getHealthChange(packetMetadata, entity) {
        const oldHealth = this.getHealthFromMetadata(entity.metadata);
        const newHealth = this.getHealthFromMetadata(this.parseMetadata(packetMetadata, entity.metadata));
        return -(oldHealth - newHealth);
    }
    getDistanceToEntity(entity) {
        return this.getDistanceBetweenEntities(this.bot.entity, entity);
    }
    getDistanceBetweenEntities(first, second) {
        return first.position.distanceTo(second.position);
    }
    getEntityAABB(entity) {
        var _a;
        switch (entity.type) {
            case "player":
                return this.getPlayerAABB({ position: entity.position });
            case "mob":
            default:
                //TODO: Implement better AABBs. However, this may just be correct.
                return this.getEntityAABBRaw({ position: entity.position, height: entity.height, width: (_a = entity.width) !== null && _a !== void 0 ? _a : entity.height });
        }
    }
    getPlayerAABB(entity) {
        return this.getEntityAABBRaw({ position: entity.position, height: 1.8, width: 0.6 });
    }
    getEntityAABBRaw(entity) {
        const w = entity.width ? entity.width / 2 : entity.height / 2;
        const { x, y, z } = entity.position;
        return new aabb_1.AABB(-w, 0, -w, w, entity.height, w).offset(x, y, z);
    }
    parseMetadata(packetMetadata, entityMetadata = {}) {
        if (packetMetadata !== undefined) {
            for (const { key, value } of packetMetadata) {
                entityMetadata[key] = value;
            }
        }
        return entityMetadata;
    }
}
exports.EntityFunctions = EntityFunctions;
