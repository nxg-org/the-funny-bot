"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PredictiveWorld = void 0;
const vec3_1 = require("vec3");
const iterators_1 = require("../calcs/iterators");
/**
 * A class dedicated to predictive logic.
 *
 * Currently, this class can predict explosion damages of crystals using a custom world.
 */
class PredictiveWorld {
    constructor(bot) {
        this.bot = bot;
        this.blocks = {};
    }
    raycast(from, direction, range, matcher = null) {
        const iter = new iterators_1.RaycastIterator(from, direction, range);
        let pos = iter.next();
        while (pos) {
            const position = new vec3_1.Vec3(pos.x, pos.y, pos.z);
            const block = this.getBlock(position);
            if (block && (!matcher || matcher(block))) {
                const intersect = iter.intersect(block.shapes, position);
                if (intersect) {
                    //@ts-expect-error 2
                    block.face = intersect.face;
                    //@ts-expect-error
                    block.intersect = intersect.pos;
                    return block;
                }
            }
            pos = iter.next();
        }
        return null;
    }
    /**
     * this works
     * @param {Block} block
     */
    setBlock(pos, block) {
        var _a;
        var _b, _c;
        (_a = (_b = this.blocks)[_c = pos.toString()]) !== null && _a !== void 0 ? _a : (_b[_c] = block);
    }
    /**
     * @param {Overwrites} blocks Blocks indexed by position.toString()
     */
    setBlocks(blocks) {
        for (const index in blocks)
            this.blocks[index] = blocks[index];
    }
    /**
     * @param {Vec3} pos
     * @returns {Block} Block at position.
     */
    getBlock(pos) {
        const pblock = this.blocks[pos.toString()];
        if (pblock !== undefined && pblock !== null)
            return pblock;
        return this.bot.blockAt(pos);
    }
    removeBlock(pos, force) {
        if (force) {
            delete this.blocks[pos.toString()];
        }
        else {
            const realBlock = this.bot.blockAt(pos);
            if (realBlock)
                this.blocks[pos.toString()] = realBlock;
            else
                delete this.blocks[pos.toString()];
        }
    }
    removeBlocks(positions, force) {
        positions.forEach((pos) => this.removeBlock(pos, force));
    }
    /**
     * @param playerPos Position of effected entity.
     * @param explosionPos Position of explosion origin.
     * @param block bot.block
     * @returns List of affected blocks that potentially protect the entity.
     */
    getExplosionAffectedBlocks(playerPos, explosionPos) {
        let blocks = {};
        const dx = 1 / (0.6 * 2 + 1);
        const dy = 1 / (1.8 * 2 + 1);
        const dz = 1 / (0.6 * 2 + 1);
        const d3 = (1 - Math.floor(1 / dx) * dx) / 2;
        const d4 = (1 - Math.floor(1 / dz) * dz) / 2;
        const pos = new vec3_1.Vec3(0, 0, 0);
        for (pos.y = playerPos.y; pos.y <= playerPos.y + 1.8; pos.y += 1.8 * dy) {
            for (pos.x = playerPos.x - 0.3 + d3; pos.x <= playerPos.x + 0.3; pos.x += 0.6 * dx) {
                for (pos.z = playerPos.z - 0.3 + d4; pos.z <= playerPos.z + 0.3; pos.z += 0.6 * dz) {
                    const dir = pos.minus(explosionPos);
                    const range = dir.norm();
                    const potentialBlock = this.raycast(explosionPos, dir.normalize(), range);
                    if (potentialBlock !== null)
                        blocks[potentialBlock.position.toString()] = potentialBlock;
                }
            }
        }
        return blocks;
    }
    loadExplosionAffectedBlocks(playerPos, explosionPos) {
        this.setBlocks(this.getExplosionAffectedBlocks(playerPos, explosionPos));
    }
}
exports.PredictiveWorld = PredictiveWorld;
