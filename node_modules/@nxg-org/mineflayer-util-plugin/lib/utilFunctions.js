"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UtilFunctions = void 0;
const entityFunctions_1 = require("./entityFunctions");
const filterFunctions_1 = require("./filterFunctions");
const inventoryFunctions_1 = require("./inventoryFunctions");
const movementFunctions_1 = require("./movementFunctions");
const util_1 = require("util");
const predictiveFunctions_1 = require("./predictiveFunctions");
const mathUtil_1 = require("./mathUtil");
const WorldFunctions_1 = require("./WorldFunctions");
const rayTracingFunctions_1 = require("./rayTracingFunctions");
class UtilFunctions {
    constructor(bot) {
        this.bot = bot;
        this.sleep = (0, util_1.promisify)(setTimeout);
        this.inv = new inventoryFunctions_1.InventoryFunctions(bot);
        this.move = new movementFunctions_1.MovementFunctions(bot);
        this.entity = new entityFunctions_1.EntityFunctions(bot);
        this.predict = new predictiveFunctions_1.PredictiveFunctions(bot);
        this.filters = new filterFunctions_1.FilterFunctions(bot);
        this.world = new WorldFunctions_1.WorldFunctions(bot);
        this.raytrace = new rayTracingFunctions_1.RayTraceFunctions(bot);
        this.math = new mathUtil_1.MathFunctions();
        this.builtInsPriorityStore = {};
        this.customPriorityStore = {};
        this.builtInCurrentExecuting = {};
        this.customCurrentExecuting = {};
    }
    isBuiltInsEmpty(name) {
        var _a;
        if (name) {
            return !((_a = this.builtInsPriorityStore[name]) === null || _a === void 0 ? void 0 : _a.length) || !this.builtInCurrentExecuting[name];
        }
        else {
            return !Object.values(this.builtInsPriorityStore).length || !Object.values(this.builtInCurrentExecuting).length;
        }
    }
    isCustomEmpty(name) {
        var _a;
        if (name) {
            return !((_a = this.customPriorityStore[name]) === null || _a === void 0 ? void 0 : _a.length) && !this.customCurrentExecuting[name];
        }
        else {
            return !Object.values(this.customPriorityStore).length && !Object.values(this.customCurrentExecuting).length;
        }
    }
    /**
     *
     * @param object \{priority, errCancel} => priority of function (highest order first), throw error if already running a function.
     * @param func any custom function.
     * @param args the arguments of passed in function.
     * @returns Error if errCancel and already executing, otherwise result of function.
     */
    customPriority({ priority, group, returnIfRunning, errCancel }, func, ...args) {
        var _a, _b;
        var _c;
        const name = (_a = group !== null && group !== void 0 ? group : func.name) !== null && _a !== void 0 ? _a : "anonymous";
        const actionQueue = ((_b = (_c = this.customPriorityStore)[name]) !== null && _b !== void 0 ? _b : (_c[name] = []));
        // console.log("custom", group ?? func.name ?? "anonymous", actionQueue, this.isCustomEmpty(name))
        if (errCancel && actionQueue.length > 1)
            throw "already executing";
        if (returnIfRunning && !this.isCustomEmpty(name))
            return 1;
        // console.log("running.")
        return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
            var _d, _e;
            const currentlyExecuting = actionQueue.shift();
            if (currentlyExecuting)
                this.customCurrentExecuting[(_d = group !== null && group !== void 0 ? group : currentlyExecuting[1].name) !== null && _d !== void 0 ? _d : "anonymous"] = currentlyExecuting;
            const index = actionQueue.findIndex(([prio]) => priority > prio);
            actionQueue.splice(index === -1 ? actionQueue.length : index, 0, [
                priority,
                () => __awaiter(this, void 0, void 0, function* () {
                    var _f;
                    try {
                        res(yield func(...args));
                    }
                    catch (e) {
                        rej(e);
                    }
                    actionQueue.shift();
                    yield ((_f = actionQueue[0]) === null || _f === void 0 ? void 0 : _f[1]());
                }),
            ]);
            if (currentlyExecuting) {
                actionQueue.unshift(currentlyExecuting);
                this.customCurrentExecuting[(_e = group !== null && group !== void 0 ? group : currentlyExecuting[1].name) !== null && _e !== void 0 ? _e : "anonymous"] = undefined;
            }
            else
                yield actionQueue[0][1]();
        }));
    }
    builtInsPriority({ group, priority, returnIfRunning, errCancel }, func, ...args) {
        var _a;
        var _b;
        const actionQueue = ((_a = (_b = this.builtInsPriorityStore)[group]) !== null && _a !== void 0 ? _a : (_b[group] = []));
        // console.log("builtin", group, actionQueue)
        if (errCancel && !this.isBuiltInsEmpty(group))
            throw "already executing";
        if (returnIfRunning && !this.isBuiltInsEmpty(group))
            return 1;
        return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
            const currentlyExecuting = actionQueue.shift();
            if (currentlyExecuting)
                this.customCurrentExecuting[group] = currentlyExecuting;
            const index = actionQueue.findIndex(([prio]) => priority > prio);
            actionQueue.splice(index === -1 ? actionQueue.length : index, 0, [
                priority,
                () => __awaiter(this, void 0, void 0, function* () {
                    var _c;
                    try {
                        res(yield func.bind(this.bot)(...args));
                    }
                    catch (e) {
                        rej(e);
                    }
                    actionQueue.shift();
                    yield ((_c = actionQueue[0]) === null || _c === void 0 ? void 0 : _c[1]());
                }),
            ]);
            if (currentlyExecuting) {
                actionQueue.unshift(currentlyExecuting);
                this.builtInCurrentExecuting[group] = undefined;
            }
            else
                yield actionQueue[0][1]();
        }));
    }
}
exports.UtilFunctions = UtilFunctions;
