"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MovementFunctions = void 0;
const mineflayer_pathfinder_1 = require("mineflayer-pathfinder");
const minecraft_data_1 = __importDefault(require("minecraft-data"));
const { GoalCompositeAll, GoalInvert, GoalFollow } = mineflayer_pathfinder_1.goals;
class MovementFunctions {
    constructor(bot) {
        this.bot = bot;
        this.goalArray = new GoalCompositeAll();
        this.movements = new mineflayer_pathfinder_1.Movements(bot, (0, minecraft_data_1.default)(bot.version));
    }
    set movements(movements) {
        this.bot.pathfinder.setMovements(movements);
    }
    get movements() {
        return this.movements;
    }
    /**
     * Fuckin' mineflayer-pathfinder still doesn't have typings.
     * Pain in my goddamn ass.
     * @returns have the goal changed
     */
    addGoal(goal) {
        if (this.goalArray.goals.find((inGoal) => inGoal === goal))
            return false;
        this.goalArray.push(goal);
        return true;
    }
    /**
     * Sets current goal and clears all others.
     * @param goal any type of mineflayer-pathfinder goal.
     * @returns have the goal changed
     */
    setOnlyGoal(goal, dynamic = false) {
        const goalArr = [goal];
        if (this.goalArray.goals === goalArr)
            return false;
        this.goalArray.goals = goalArr;
        this.bot.pathfinder.setGoal(this.goalArray, dynamic);
        return true;
    }
    /**
     * Reset all goals inside the goal array to none.
     * @returns have the goals changed
     */
    stop() {
        if (this.goalArray.goals.length === 0)
            return false;
        this.goalArray.goals = [];
        this.bot.pathfinder.setGoal(null);
        return true;
    }
    /**
     * Retreat from current entity.
     * @param entity Prismarine-Entity Entity
     * @returns have the goals changed.
     */
    retreatFromEntity(entity, distance, dynamic = true) {
        const oldGoals = this.goalArray.goals.length;
        this.goalArray.goals = this.goalArray.goals.filter((goal) => { var _a, _b, _c; return ((_b = (_a = goal.goal) === null || _a === void 0 ? void 0 : _a.entity) === null || _b === void 0 ? void 0 : _b.id) === entity.id && ((_c = goal.goal) === null || _c === void 0 ? void 0 : _c.rangeSq) === distance * distance; });
        if (oldGoals !== this.goalArray.goals.length || this.goalArray.goals.length === 0) {
            this.goalArray.push(new GoalFollow(entity, distance));
            this.goalArray.push(new GoalInvert(new GoalFollow(entity, distance - 1)));
            this.bot.pathfinder.setGoal(this.goalArray, dynamic);
            return true;
        }
        return false;
    }
    /**
     * Follow entity with a specific range. Will not approach past a certain distance either.
     * @param entity Prismarine-Entity Entity
     * @returns have the goals changed
     */
    followEntityWithRespectRange(entity, followDistance, invertDistance) {
        const oldGoals = this.goalArray.goals.length;
        this.goalArray.goals = this.goalArray.goals.filter((goal) => {
            var _a;
            return ((_a = goal.entity) === null || _a === void 0 ? void 0 : _a.id) === entity.id && goal.rangeSq === followDistance * followDistance;
        });
        if (oldGoals !== this.goalArray.goals.length || !this.bot.pathfinder.isMoving() || this.goalArray.goals.length === 0) {
            if (this.goalArray.goals.length > 0) {
                this.goalArray.goals = [];
            }
            this.goalArray.push(new GoalFollow(entity, followDistance));
            this.goalArray.push(new GoalInvert(new GoalFollow(entity, invertDistance !== null && invertDistance !== void 0 ? invertDistance : followDistance - 0.5)));
            this.bot.pathfinder.setGoal(this.goalArray, true);
            return true;
        }
        return false;
    }
    forceLook(yaw, pitch, update = false, onGround) {
        const notchianYawAndPitch = { yaw: this.bot.util.math.toNotchianYaw(yaw), pitch: this.bot.util.math.toNotchianPitch(pitch) };
        this.bot._client.write("look", Object.assign(Object.assign({}, notchianYawAndPitch), { onGround: onGround !== null && onGround !== void 0 ? onGround : this.bot.entity.onGround }));
        if (update) {
            this.bot.look(yaw, pitch, true);
        }
    }
    forceLookAt(pos, update = false, onGround) {
        const { yaw, pitch } = this.bot.util.math.pointToYawAndPitch(this.bot, pos);
        const nyp = { yaw: this.bot.util.math.toNotchianYaw(yaw), pitch: this.bot.util.math.toNotchianPitch(pitch) };
        this.bot._client.write("look", Object.assign(Object.assign({}, nyp), { onGround: onGround !== null && onGround !== void 0 ? onGround : this.bot.entity.onGround }));
        if (update) {
            this.bot.look(yaw, pitch, true);
        }
    }
    lazyTeleport(endPos) { }
}
exports.MovementFunctions = MovementFunctions;
